<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A doc-only module explaining how to run core library tests."><title>swarm_nl::testing_guide - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="swarm_nl" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../swarm_nl/index.html">swarm_nl</a><span class="version">0.1.0</span></h2></div><h2 class="location"><a href="#">Module testing_guide</a></h2><div class="sidebar-elems"><h2><a href="../index.html">In crate swarm_nl</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../swarm_nl/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">swarm_nl</a>::<wbr><a class="mod" href="#">testing_guide</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/swarm_nl/testing_guide.rs.html#1-146">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A doc-only module explaining how to run core library tests.</p>
<p>There are two classes of tests in the core library:</p>
<ul>
<li><code>node_behaviour</code> tests for single node setup and behaviour.</li>
<li><code>layer_communication</code> tests involving the synchronization between two nodes.</li>
</ul>
<h2 id="node-behaviour-testing"><a class="doc-anchor" href="#node-behaviour-testing">§</a>Node behaviour testing</h2>
<p>These are simple unit tests that check the behaviour of a single node. To run these tests, simply run the following command:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test node_
</code></pre></div><h2 id="layer-communication-testing"><a class="doc-anchor" href="#layer-communication-testing">§</a>Layer communication testing</h2>
<p>In order to create tests for communication between two nodes, we used the Rust conditional compilation feature to be able to setup different nodes and test their communication.
All commands for running these tests should be run with <code>-- --nocapture</code> to verify the expected results.</p>
<p>For these tests, we’ve created two test nodes: <code>node1</code> and <code>node2</code>. </p>
<ul>
<li>
<p>Node 1 is setup by calling the <code>setup_node_1</code> function which uses a pre-configured cryptographic keypair and the <code>setup_core_builder_1</code> function to configure a default node.
This keeps its identity consistent across tests.</p>
</li>
<li>
<p>Node 2 is setup by calling the <code>setup_node_2</code> function which creates a new node identity every time it is called. 
It then adds Node 1 as its bootnode and establishes a connection by dialing Node 1.</p>
</li>
</ul>
<h4 id="peer-dialing-tests"><a class="doc-anchor" href="#peer-dialing-tests">§</a>Peer dialing tests</h4>
<p>The peer dialing tests checks if a node can dial another node by using a <code>listening</code> node and a <code>dialing</code> node.
To run these tests, start the listening node by running the following command in one terminal:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test dialing_peer_works --features=test-listening-node -- --nocapture
</code></pre></div>
<p>Then, in another terminal run the dialing node:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test dialing_peer_works --features=test-dialling-node -- --nocapture
</code></pre></div>
<p>The application event handler will log the dialing node’s peer id and the listening node’s peer id.</p>
<h3 id="fetching-tests"><a class="doc-anchor" href="#fetching-tests">§</a>Fetching tests</h3>
<p>The fetching test checks if a node can fetch a value from another node.
These tests use a <code>server</code> node and a <code>client</code> node.</p>
<p>To run these tests first start the server node in one terminal:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test rpc_fetch_works --features=server-node -- --nocapture
</code></pre></div>
<p>And in another terminal, run the client node:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test rpc_fetch_works --features=client-node -- --nocapture
</code></pre></div>
<p>Then you can check that the server node prints out a <em>“Recvd incoming RPC:”</em> message with the data sent by the client node.</p>
<h3 id="kademlia-tests"><a class="doc-anchor" href="#kademlia-tests">§</a>Kademlia tests</h3>
<p>For Kademlia tests, we have a <code>reading</code> node and a <code>writing</code> node. 
We use a time delay to simulate the reading node “sleeping” so as to allow the writing node to make changes to the DHT.</p>
<p>When the reading node “wakes up” it then tries to read the value from the DHT. If the value is what it expects, the tests passes successfully.</p>
<p>To run this test, run the following command in one terminal to launch the “reading” node:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test kademlia_record_store_itest_works --features=test-reading-node -- --nocapture
</code></pre></div>
<p>And then run the following command in another terminal to launch the “writing node”:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test kademlia_record_store_itest_works --features=test-writing-node -- --nocapture
</code></pre></div><h4 id="record-providers-tests"><a class="doc-anchor" href="#record-providers-tests">§</a>Record providers tests</h4>
<p>To run the providers tests, we have a <code>reading</code> node and a <code>writing</code> node.</p>
<p>We first run the “writing” node to store a record in the DHT. Then we run a “reading” node to fetch the list of providers of the record that’s been written.</p>
<p>Then we simply assert that node 1 is a provider of the record.</p>
<p>To run this test, first run the “writing” node:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test kademlia_provider_records_itest_works --features=test-writing-node -- --nocapture
</code></pre></div>
<p>Then, in another terminal, run the “reading” node:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test kademlia_provider_records_itest_works --features=test-reading-node -- --nocapture
</code></pre></div><h4 id="gossipsub-tests"><a class="doc-anchor" href="#gossipsub-tests">§</a>Gossipsub tests</h4>
<p><strong>Join/Exit tests</strong></p>
<p>For Gossipsub tests, we have a <code>subscribe</code> node and a <code>query</code> node.</p>
<p>When the “subscribe” node is set up, it joins a mesh network. Then node 2 is setup and connects to node 1, sleeps for a while (to allow propagtion of data from node 1) and then joins the network.
After joining, it then queries the network layer for gossipping information. This information contains topics the node is currently subscribed to such as the peers that node 2 knows (which is node 1) and the network they are a part of.
The peers that have been blacklisted are also returned.</p>
<p>In this test, we test that node 1 is a part of the mesh network that node 2 is subscribed to.</p>
<p>To run this test, first run the “subscribe” node:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test gossipsub_join_exit_itest_works --features=test-subscribe-node -- --nocapture
</code></pre></div>
<p>Then, in another terminal, run the “query” node:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test gossipsub_join_exit_itest_works --features=test-query-node -- --nocapture
</code></pre></div>
<p><strong>Publish/Subscribe tests</strong></p>
<p>For this test we have a <code>listening</code> node and a <code>broadcast</code> node. The first node is setup which joins a mesh network. Then, node 2 is setup and connects to node 1, sleeps for a few seconds (to allow propagtion of data from node 1) and then joins the network.
It then joins the network that node 1 was already a part of and sends a broadcast message to every peer in the mesh network.</p>
<p>The indicator of the success of this test is revealed in the applications’ event handler function (see: <a href="../core/prelude/trait.EventHandler.html#tymethod.gossipsub_handle_incoming_message" title="method swarm_nl::core::prelude::EventHandler::gossipsub_handle_incoming_message"><code>crate::core::EventHandler::gossipsub_handle_incoming_message</code></a>) which logs the message received from node 2.</p>
<p>To run this test, first run the “listening” node in one terminal:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test gossipsub_message_itest_works --features=test-listening-node -- --nocapture
</code></pre></div>
<p>Then run the “broadcast” node in another terminal:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test gossipsub_message_itest_works --features=test-broadcast-node -- --nocapture
</code></pre></div></div></details></section></div></main></body></html>