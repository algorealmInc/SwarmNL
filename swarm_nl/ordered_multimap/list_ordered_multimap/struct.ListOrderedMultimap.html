<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A multimap that associates with each key a list of values."><title>ListOrderedMultimap in ordered_multimap::list_ordered_multimap - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="ordered_multimap" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../ordered_multimap/index.html">ordered_multimap</a><span class="version">0.7.3</span></h2></div><h2 class="location"><a href="#">ListOrderedMultimap</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.append">append</a></li><li><a href="#method.back">back</a></li><li><a href="#method.back_mut">back_mut</a></li><li><a href="#method.clear">clear</a></li><li><a href="#method.contains_key">contains_key</a></li><li><a href="#method.entry">entry</a></li><li><a href="#method.entry_len">entry_len</a></li><li><a href="#method.front">front</a></li><li><a href="#method.front_mut">front_mut</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_all">get_all</a></li><li><a href="#method.get_all_mut">get_all_mut</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.hasher">hasher</a></li><li><a href="#method.insert">insert</a></li><li><a href="#method.insert_all">insert_all</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.iter_mut">iter_mut</a></li><li><a href="#method.keys">keys</a></li><li><a href="#method.keys_capacity">keys_capacity</a></li><li><a href="#method.keys_len">keys_len</a></li><li><a href="#method.new">new</a></li><li><a href="#method.pack_to">pack_to</a></li><li><a href="#method.pack_to_fit">pack_to_fit</a></li><li><a href="#method.pairs">pairs</a></li><li><a href="#method.pairs_mut">pairs_mut</a></li><li><a href="#method.pop_back">pop_back</a></li><li><a href="#method.pop_front">pop_front</a></li><li><a href="#method.remove">remove</a></li><li><a href="#method.remove_all">remove_all</a></li><li><a href="#method.remove_entry">remove_entry</a></li><li><a href="#method.remove_entry_all">remove_entry_all</a></li><li><a href="#method.reserve_keys">reserve_keys</a></li><li><a href="#method.reserve_values">reserve_values</a></li><li><a href="#method.retain">retain</a></li><li><a href="#method.values">values</a></li><li><a href="#method.values_capacity">values_capacity</a></li><li><a href="#method.values_len">values_len</a></li><li><a href="#method.values_mut">values_mut</a></li><li><a href="#method.with_capacity">with_capacity</a></li><li><a href="#method.with_capacity_and_hasher">with_capacity_and_hasher</a></li><li><a href="#method.with_hasher">with_hasher</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-ListOrderedMultimap%3CKey,+Value,+State%3E">Clone</a></li><li><a href="#impl-Debug-for-ListOrderedMultimap%3CKey,+Value,+State%3E">Debug</a></li><li><a href="#impl-Default-for-ListOrderedMultimap%3CKey,+Value%3E">Default</a></li><li><a href="#impl-Eq-for-ListOrderedMultimap%3CKey,+Value,+State%3E">Eq</a></li><li><a href="#impl-Extend%3C(%26Key,+%26Value)%3E-for-ListOrderedMultimap%3CKey,+Value,+State%3E">Extend&lt;(&amp;&#x27;a Key, &amp;&#x27;a Value)&gt;</a></li><li><a href="#impl-Extend%3C(Key,+Value)%3E-for-ListOrderedMultimap%3CKey,+Value,+State%3E">Extend&lt;(Key, Value)&gt;</a></li><li><a href="#impl-FromIterator%3C(Key,+Value)%3E-for-ListOrderedMultimap%3CKey,+Value,+State%3E">FromIterator&lt;(Key, Value)&gt;</a></li><li><a href="#impl-IntoIterator-for-%26ListOrderedMultimap%3CKey,+Value,+State%3E">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-%26mut+ListOrderedMultimap%3CKey,+Value,+State%3E">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-ListOrderedMultimap%3CKey,+Value,+State%3E">IntoIterator</a></li><li><a href="#impl-PartialEq-for-ListOrderedMultimap%3CKey,+Value,+State%3E">PartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-ListOrderedMultimap%3CKey,+Value,+State%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-ListOrderedMultimap%3CKey,+Value,+State%3E">Send</a></li><li><a href="#impl-Sync-for-ListOrderedMultimap%3CKey,+Value,+State%3E">Sync</a></li><li><a href="#impl-Unpin-for-ListOrderedMultimap%3CKey,+Value,+State%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-ListOrderedMultimap%3CKey,+Value,+State%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-Equivalent%3CK%3E-for-Q">Equivalent&lt;K&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In ordered_multimap::list_ordered_multimap</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../ordered_multimap/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">ordered_multimap</a>::<wbr><a href="index.html">list_ordered_multimap</a>::<wbr><a class="struct" href="#">ListOrderedMultimap</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#71-87">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct ListOrderedMultimap&lt;Key, Value, State = <a class="type" href="type.RandomState.html" title="type ordered_multimap::list_ordered_multimap::RandomState">RandomState</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A multimap that associates with each key a list of values.</p>
<h2 id="ordering"><a class="doc-anchor" href="#ordering">§</a>Ordering</h2>
<p>The primary guarantee this type gives is that regardless of what you do to the multimap, you are always able to
iterate through all keys and values in the order they were inserted. Values can be iterated by their insertion order
either for a specific key or for the entire map.</p>
<h2 id="allocations"><a class="doc-anchor" href="#allocations">§</a>Allocations</h2>
<p>Allocations may be performed on any key-value insertion.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-ListOrderedMultimap%3CKey,+Value%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#90-142">source</a><a href="#impl-ListOrderedMultimap%3CKey,+Value%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value&gt; <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, <a class="type" href="type.RandomState.html" title="type ordered_multimap::list_ordered_multimap::RandomState">RandomState</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#103-110">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, <a class="type" href="type.RandomState.html" title="type ordered_multimap::list_ordered_multimap::RandomState">RandomState</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new multimap with no initial capacity.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
map.insert(<span class="string">"key1"</span>, <span class="string">"value1"</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key1"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value1"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_capacity" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#131-141">source</a><h4 class="code-header">pub fn <a href="#method.with_capacity" class="fn">with_capacity</a>(
    key_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>,
    value_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, <a class="type" href="type.RandomState.html" title="type ordered_multimap::list_ordered_multimap::RandomState">RandomState</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new multimap with the specified capacities.</p>
<p>The multimap will be able to hold at least <code>key_capacity</code> keys and <code>value_capacity</code> values without reallocating.
A capacity of 0 will result in no allocation for the respective container.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span>map: ListOrderedMultimap&lt;<span class="kw-2">&amp;</span>str, <span class="kw-2">&amp;</span>str&gt; = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.keys_capacity(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(map.values_capacity(), <span class="number">0</span>);

<span class="kw">let </span>map: ListOrderedMultimap&lt;<span class="kw-2">&amp;</span>str, <span class="kw-2">&amp;</span>str&gt; = ListOrderedMultimap::with_capacity(<span class="number">5</span>, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(map.keys_capacity(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(map.values_capacity(), <span class="number">10</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#144-208">source</a><a href="#impl-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_capacity_and_hasher" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#170-181">source</a><h4 class="code-header">pub fn <a href="#method.with_capacity_and_hasher" class="fn">with_capacity_and_hasher</a>(
    key_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>,
    value_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>,
    state: State
) -&gt; <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;</h4></section></summary><div class="docblock"><p>Creates a new multimap with the specified capacities and the given hash builder to hash keys.</p>
<p>The multimap will be able to hold at least <code>key_capacity</code> keys and <code>value_capacity</code> values without reallocating. A
capacity of 0 will result in no allocation for the respective container.</p>
<p>The <code>state</code> is normally randomly generated and is designed to allow multimaps to be resistant to attacks that
cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack
vector.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;
<span class="kw">use </span>std::collections::hash_map::RandomState;

<span class="kw">let </span>state = RandomState::new();
<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::with_capacity_and_hasher(<span class="number">10</span>, <span class="number">10</span>, state);
map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.keys_capacity(), <span class="number">10</span>);
<span class="macro">assert_eq!</span>(map.values_capacity(), <span class="number">10</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_hasher" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#200-207">source</a><h4 class="code-header">pub fn <a href="#method.with_hasher" class="fn">with_hasher</a>(state: State) -&gt; <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;</h4></section></summary><div class="docblock"><p>Creates a new multimap with no capacity which will use the given hash builder to hash keys.</p>
<p>The <code>state</code> is normally randomly generated and is designed to allow multimaps to be resistant to attacks that
cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack
vector.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;
<span class="kw">use </span>std::collections::hash_map::RandomState;

<span class="kw">let </span>state = RandomState::new();
<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::with_hasher(state);
map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ListOrderedMultimap%3CKey,+Value,+State%3E-1" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#210-670">source</a><a href="#impl-ListOrderedMultimap%3CKey,+Value,+State%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.back" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#227-229">source</a><h4 class="code-header">pub fn <a href="#method.back" class="fn">back</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Key</a>, <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Value</a>)&gt;</h4></section></summary><div class="docblock"><p>Returns an immutable reference to the first key-value pair in the multimap</p>
<p>Complexity: O(1)</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.back(), <span class="prelude-val">None</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.back(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key"</span>, <span class="kw-2">&amp;</span><span class="string">"value"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.back_mut" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#247-249">source</a><h4 class="code-header">pub fn <a href="#method.back_mut" class="fn">back_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Key</a>, <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut Value</a>)&gt;</h4></section></summary><div class="docblock"><p>Returns an immutable reference to the first key-value pair in the multimap</p>
<p>Complexity: O(1)</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.back_mut(), <span class="prelude-val">None</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.back_mut(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key"</span>, <span class="kw-2">&amp;mut </span><span class="string">"value"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#269-273">source</a><h4 class="code-header">pub fn <a href="#method.clear" class="fn">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Removes all keys and values from the multimap.</p>
<p>Complexity: O(|K| + |V|) where |K| is the number of keys and |V| is the number of values.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.keys_len(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">1</span>);

map.clear();
<span class="macro">assert_eq!</span>(map.keys_len(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.front" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#291-293">source</a><h4 class="code-header">pub fn <a href="#method.front" class="fn">front</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Key</a>, <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Value</a>)&gt;</h4></section></summary><div class="docblock"><p>Returns an immutable reference to the first key-value pair in the multimap</p>
<p>Complexity: O(1)</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.front(), <span class="prelude-val">None</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.front(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key"</span>, <span class="kw-2">&amp;</span><span class="string">"value"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.front_mut" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#311-313">source</a><h4 class="code-header">pub fn <a href="#method.front_mut" class="fn">front_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Key</a>, <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut Value</a>)&gt;</h4></section></summary><div class="docblock"><p>Returns an immutable reference to the first key-value pair in the multimap</p>
<p>Complexity: O(1)</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.front_mut(), <span class="prelude-val">None</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.front_mut(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key"</span>, <span class="kw-2">&amp;mut </span><span class="string">"value"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.hasher" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#326-328">source</a><h4 class="code-header">pub fn <a href="#method.hasher" class="fn">hasher</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;State</a></h4></section></summary><div class="docblock"><p>Returns a reference to the multimap’s <a href="https://doc.rust-lang.org/1.77.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher"><code>BuildHasher</code></a>.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span>map: ListOrderedMultimap&lt;<span class="kw-2">&amp;</span>str, <span class="kw-2">&amp;</span>str&gt; = ListOrderedMultimap::new();
<span class="kw">let </span>hasher = map.hasher();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#347-349">source</a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether the multimap is empty.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert!</span>(map.is_empty());

map.insert(<span class="string">"key1"</span>, <span class="string">"value"</span>);
<span class="macro">assert!</span>(!map.is_empty());

map.remove(<span class="kw-2">&amp;</span><span class="string">"key1"</span>);
<span class="macro">assert!</span>(map.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#373-378">source</a><h4 class="code-header">pub fn <a href="#method.iter" class="fn">iter</a>(&amp;self) -&gt; <a class="struct" href="struct.Iter.html" title="struct ordered_multimap::list_ordered_multimap::Iter">Iter</a>&lt;'_, Key, Value&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;&#39;_, Key, Value&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator that yields immutable references to all key-value pairs in the multimap by insertion order.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
map.insert(<span class="string">"key1"</span>, <span class="string">"value1"</span>);
map.insert(<span class="string">"key2"</span>, <span class="string">"value1"</span>);
map.append(<span class="kw-2">&amp;</span><span class="string">"key1"</span>, <span class="string">"value2"</span>);
map.append(<span class="kw-2">&amp;</span><span class="string">"key2"</span>, <span class="string">"value2"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>iter = map.iter();
<span class="macro">assert_eq!</span>(iter.size_hint(), (<span class="number">4</span>, <span class="prelude-val">Some</span>(<span class="number">4</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key1"</span>, <span class="kw-2">&amp;</span><span class="string">"value1"</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key2"</span>, <span class="kw-2">&amp;</span><span class="string">"value1"</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key1"</span>, <span class="kw-2">&amp;</span><span class="string">"value2"</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key2"</span>, <span class="kw-2">&amp;</span><span class="string">"value2"</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter_mut" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#410-415">source</a><h4 class="code-header">pub fn <a href="#method.iter_mut" class="fn">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.IterMut.html" title="struct ordered_multimap::list_ordered_multimap::IterMut">IterMut</a>&lt;'_, Key, Value&gt; <a href="#" class="tooltip" data-notable-ty="IterMut&lt;&#39;_, Key, Value&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator that yields mutable references to all key-value pairs in the multimap by insertion order.</p>
<p>Only the values are mutable, the keys are immutable.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
map.insert(<span class="string">"key1"</span>, <span class="string">"value1"</span>);
map.insert(<span class="string">"key2"</span>, <span class="string">"value1"</span>);
map.append(<span class="kw-2">&amp;</span><span class="string">"key1"</span>, <span class="string">"value2"</span>);
map.append(<span class="kw-2">&amp;</span><span class="string">"key2"</span>, <span class="string">"value2"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>iter = map.iter_mut();
<span class="macro">assert_eq!</span>(iter.size_hint(), (<span class="number">4</span>, <span class="prelude-val">Some</span>(<span class="number">4</span>)));

<span class="kw">let </span>first = iter.next().unwrap();
<span class="macro">assert_eq!</span>(first, (<span class="kw-2">&amp;</span><span class="string">"key1"</span>, <span class="kw-2">&amp;mut </span><span class="string">"value1"</span>));
<span class="kw-2">*</span>first.<span class="number">1 </span>= <span class="string">"value3"</span>;

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key2"</span>, <span class="kw-2">&amp;mut </span><span class="string">"value1"</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key1"</span>, <span class="kw-2">&amp;mut </span><span class="string">"value2"</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key2"</span>, <span class="kw-2">&amp;mut </span><span class="string">"value2"</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">None</span>);

<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key1"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value3"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.keys" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#439-441">source</a><h4 class="code-header">pub fn <a href="#method.keys" class="fn">keys</a>(&amp;self) -&gt; <a class="struct" href="struct.Keys.html" title="struct ordered_multimap::list_ordered_multimap::Keys">Keys</a>&lt;'_, Key&gt; <a href="#" class="tooltip" data-notable-ty="Keys&lt;&#39;_, Key&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator that yields immutable references to all keys in the multimap by insertion order.</p>
<p>Insertion order of keys is determined by the order in which a given key is first inserted into the multimap with a
value. Any subsequent insertions with that key without first removing it will not affect its ordering.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
map.insert(<span class="string">"key1"</span>, <span class="string">"value"</span>);
map.insert(<span class="string">"key2"</span>, <span class="string">"value"</span>);
map.insert(<span class="string">"key3"</span>, <span class="string">"value"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>keys = map.keys();
<span class="macro">assert_eq!</span>(keys.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"key1"</span>));
<span class="macro">assert_eq!</span>(keys.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"key2"</span>));
<span class="macro">assert_eq!</span>(keys.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"key3"</span>));
<span class="macro">assert_eq!</span>(keys.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.keys_capacity" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#459-461">source</a><h4 class="code-header">pub fn <a href="#method.keys_capacity" class="fn">keys_capacity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of keys the multimap can hold without reallocating.</p>
<p>This number is a lower bound, and the multimap may be able to hold more.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.keys_capacity(), <span class="number">0</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert!</span>(map.keys_capacity() &gt; <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.keys_len" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#479-481">source</a><h4 class="code-header">pub fn <a href="#method.keys_len" class="fn">keys_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of keys in the multimap.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.keys_len(), <span class="number">0</span>);

map.insert(<span class="string">"key1"</span>, <span class="string">"value"</span>);
map.insert(<span class="string">"key2"</span>, <span class="string">"value"</span>);
map.insert(<span class="string">"key3"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.keys_len(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pairs" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#505-513">source</a><h4 class="code-header">pub fn <a href="#method.pairs" class="fn">pairs</a>(&amp;self) -&gt; <a class="struct" href="struct.KeyValues.html" title="struct ordered_multimap::list_ordered_multimap::KeyValues">KeyValues</a>&lt;'_, Key, Value, State&gt; <a href="#" class="tooltip" data-notable-ty="KeyValues&lt;&#39;_, Key, Value, State&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator that yields immutable references to keys and all associated values with those keys as separate
iterators. The order of yielded pairs will be the order in which the keys were first inserted into the multimap.</p>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();

map.insert(<span class="string">"key"</span>, <span class="string">"value1"</span>);
map.append(<span class="string">"key"</span>, <span class="string">"value2"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>iter = map.pairs();

<span class="kw">let </span>(key, <span class="kw-2">mut </span>values) = iter.next().unwrap();
<span class="macro">assert_eq!</span>(key, <span class="kw-2">&amp;</span><span class="string">"key"</span>);
<span class="macro">assert_eq!</span>(values.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value1"</span>));
<span class="macro">assert_eq!</span>(values.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value2"</span>));
<span class="macro">assert_eq!</span>(values.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pairs_mut" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#538-546">source</a><h4 class="code-header">pub fn <a href="#method.pairs_mut" class="fn">pairs_mut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.KeyValuesMut.html" title="struct ordered_multimap::list_ordered_multimap::KeyValuesMut">KeyValuesMut</a>&lt;'_, Key, Value, State&gt; <a href="#" class="tooltip" data-notable-ty="KeyValuesMut&lt;&#39;_, Key, Value, State&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator that yields immutable references to keys and mutable references to all associated values with
those keys as separate iterators. The order of yielded pairs will be the order in which the keys were first
inserted into the multimap.</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();

map.insert(<span class="string">"key"</span>, <span class="string">"value1"</span>);
map.append(<span class="string">"key"</span>, <span class="string">"value2"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>iter = map.pairs_mut();

<span class="kw">let </span>(key, <span class="kw-2">mut </span>values) = iter.next().unwrap();
<span class="macro">assert_eq!</span>(key, <span class="kw-2">&amp;</span><span class="string">"key"</span>);
<span class="macro">assert_eq!</span>(values.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="string">"value1"</span>));
<span class="macro">assert_eq!</span>(values.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="string">"value2"</span>));
<span class="macro">assert_eq!</span>(values.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reserve_values" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#568-570">source</a><h4 class="code-header">pub fn <a href="#method.reserve_values" class="fn">reserve_values</a>(&amp;mut self, additional_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves additional capacity such that more values can be stored in the multimap.</p>
<p>If the existing capacity minus the current length is enough to satisfy the additional capacity, the capacity will
remain unchanged.</p>
<p>If the capacity is increased, the capacity may be increased by more than what was requested.</p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::with_capacity(<span class="number">1</span>, <span class="number">1</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.values_capacity(), <span class="number">1</span>);

map.reserve_values(<span class="number">10</span>);
<span class="macro">assert!</span>(map.values_capacity() &gt;= <span class="number">11</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.values" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#594-596">source</a><h4 class="code-header">pub fn <a href="#method.values" class="fn">values</a>(&amp;self) -&gt; <a class="struct" href="struct.Values.html" title="struct ordered_multimap::list_ordered_multimap::Values">Values</a>&lt;'_, Key, Value&gt; <a href="#" class="tooltip" data-notable-ty="Values&lt;&#39;_, Key, Value&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator that yields immutable references to all values in the multimap by insertion order.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
map.insert(<span class="string">"key1"</span>, <span class="string">"value1"</span>);
map.insert(<span class="string">"key2"</span>, <span class="string">"value1"</span>);
map.append(<span class="kw-2">&amp;</span><span class="string">"key1"</span>, <span class="string">"value2"</span>);
map.append(<span class="kw-2">&amp;</span><span class="string">"key2"</span>, <span class="string">"value2"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>iter = map.values();
<span class="macro">assert_eq!</span>(iter.size_hint(), (<span class="number">4</span>, <span class="prelude-val">Some</span>(<span class="number">4</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value1"</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value1"</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value2"</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value2"</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.values_mut" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#626-628">source</a><h4 class="code-header">pub fn <a href="#method.values_mut" class="fn">values_mut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.ValuesMut.html" title="struct ordered_multimap::list_ordered_multimap::ValuesMut">ValuesMut</a>&lt;'_, Key, Value&gt; <a href="#" class="tooltip" data-notable-ty="ValuesMut&lt;&#39;_, Key, Value&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator that yields mutable references to all values in the multimap by insertion order.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
map.insert(<span class="string">"key1"</span>, <span class="string">"value1"</span>);
map.insert(<span class="string">"key2"</span>, <span class="string">"value1"</span>);
map.append(<span class="kw-2">&amp;</span><span class="string">"key1"</span>, <span class="string">"value2"</span>);
map.append(<span class="kw-2">&amp;</span><span class="string">"key2"</span>, <span class="string">"value2"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>iter = map.values_mut();
<span class="macro">assert_eq!</span>(iter.size_hint(), (<span class="number">4</span>, <span class="prelude-val">Some</span>(<span class="number">4</span>)));

<span class="kw">let </span>first = iter.next().unwrap();
<span class="macro">assert_eq!</span>(first, <span class="kw-2">&amp;mut </span><span class="string">"value1"</span>);
<span class="kw-2">*</span>first = <span class="string">"value3"</span>;

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="string">"value1"</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="string">"value2"</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="string">"value2"</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">None</span>);

<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key1"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value3"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.values_capacity" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#646-648">source</a><h4 class="code-header">pub fn <a href="#method.values_capacity" class="fn">values_capacity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of values the multimap can hold without reallocating.</p>
<p>This number is a lower bound, and the multimap may be able to hold more.</p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.values_capacity(), <span class="number">0</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert!</span>(map.values_capacity() &gt; <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.values_len" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#667-669">source</a><h4 class="code-header">pub fn <a href="#method.values_len" class="fn">values_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of values in the multimap across all keys.</p>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">0</span>);

map.insert(<span class="string">"key1"</span>, <span class="string">"value1"</span>);
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">1</span>);

map.append(<span class="string">"key1"</span>, <span class="string">"value2"</span>);
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">2</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ListOrderedMultimap%3CKey,+Value,+State%3E-2" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#672-1608">source</a><a href="#impl-ListOrderedMultimap%3CKey,+Value,+State%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.append" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#699-731">source</a><h4 class="code-header">pub fn <a href="#method.append" class="fn">append</a>(&amp;mut self, key: Key, value: Value) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Appends a value to the list of values associated with the given key.</p>
<p>If the key is not already in the multimap, this will be identical to an insert and the return value will be
<code>false</code>. Otherwise, <code>true</code> will be returned.</p>
<p>Complexity: amortized O(1)</p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="kw">let </span>already_exists = map.append(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert!</span>(!already_exists);
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value"</span>));

<span class="kw">let </span>already_exists = map.append(<span class="string">"key"</span>, <span class="string">"value2"</span>);
<span class="macro">assert!</span>(already_exists);
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains_key" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#748-755">source</a><h4 class="code-header">pub fn <a href="#method.contains_key" class="fn">contains_key</a>&lt;KeyQuery&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;KeyQuery</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a><div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;KeyQuery&gt;,
    KeyQuery: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Returns whether the given key is in the multimap.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-24"><a class="doc-anchor" href="#examples-24">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert!</span>(!map.contains_key(<span class="kw-2">&amp;</span><span class="string">"key"</span>));
map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert!</span>(map.contains_key(<span class="kw-2">&amp;</span><span class="string">"key"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.entry" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#772-797">source</a><h4 class="code-header">pub fn <a href="#method.entry" class="fn">entry</a>(&amp;mut self, key: Key) -&gt; <a class="enum" href="enum.Entry.html" title="enum ordered_multimap::list_ordered_multimap::Entry">Entry</a>&lt;'_, Key, Value, State&gt;</h4></section></summary><div class="docblock"><p>Returns whether the given key is in the multimap.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-25"><a class="doc-anchor" href="#examples-25">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="kw">let </span>value = map.entry(<span class="string">"key"</span>).or_insert(<span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(value, <span class="kw-2">&amp;</span><span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.entry_len" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#818-829">source</a><h4 class="code-header">pub fn <a href="#method.entry_len" class="fn">entry_len</a>&lt;KeyQuery&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;KeyQuery</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a><div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;KeyQuery&gt;,
    KeyQuery: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Returns the number of values associated with a key.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-26"><a class="doc-anchor" href="#examples-26">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.entry_len(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="number">0</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value1"</span>);
<span class="macro">assert_eq!</span>(map.entry_len(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="number">1</span>);

map.append(<span class="kw-2">&amp;</span><span class="string">"key"</span>, <span class="string">"value2"</span>);
<span class="macro">assert_eq!</span>(map.entry_len(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="number">2</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#846-857">source</a><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;KeyQuery&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;KeyQuery</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Value</a>&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;KeyQuery&gt;,
    KeyQuery: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Returns an immutable reference to the first value, by insertion order, associated with the given key, or <code>None</code> if
the key is not in the multimap.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-27"><a class="doc-anchor" href="#examples-27">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map: ListOrderedMultimap&lt;<span class="kw-2">&amp;</span>str, <span class="kw-2">&amp;</span>str&gt; = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">None</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_all" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#879-890">source</a><h4 class="code-header">pub fn <a href="#method.get_all" class="fn">get_all</a>&lt;KeyQuery&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;KeyQuery</a>) -&gt; <a class="struct" href="struct.EntryValues.html" title="struct ordered_multimap::list_ordered_multimap::EntryValues">EntryValues</a>&lt;'_, Key, Value&gt; <a href="#" class="tooltip" data-notable-ty="EntryValues&lt;&#39;_, Key, Value&gt;">ⓘ</a><div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;KeyQuery&gt;,
    KeyQuery: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator that yields immutable references to all values associated with the given key by insertion
order.</p>
<p>If the key is not in the multimap, the iterator will yield no values.</p>
<h5 id="examples-28"><a class="doc-anchor" href="#examples-28">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
map.append(<span class="string">"key"</span>, <span class="string">"value2"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>iter = map.get_all(<span class="kw-2">&amp;</span><span class="string">"key"</span>);
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value"</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value2"</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_all_mut" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#917-928">source</a><h4 class="code-header">pub fn <a href="#method.get_all_mut" class="fn">get_all_mut</a>&lt;KeyQuery&gt;(
    &amp;mut self,
    key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;KeyQuery</a>
) -&gt; <a class="struct" href="struct.EntryValuesMut.html" title="struct ordered_multimap::list_ordered_multimap::EntryValuesMut">EntryValuesMut</a>&lt;'_, Key, Value&gt; <a href="#" class="tooltip" data-notable-ty="EntryValuesMut&lt;&#39;_, Key, Value&gt;">ⓘ</a><div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;KeyQuery&gt;,
    KeyQuery: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator that yields mutable references to all values associated with the given key by insertion order.</p>
<p>If the key is not in the multimap, the iterator will yield no values.</p>
<h5 id="examples-29"><a class="doc-anchor" href="#examples-29">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
map.insert(<span class="string">"key"</span>, <span class="string">"value1"</span>);
map.append(<span class="string">"key"</span>, <span class="string">"value2"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>iter = map.get_all_mut(<span class="kw-2">&amp;</span><span class="string">"key"</span>);

<span class="kw">let </span>first = iter.next().unwrap();
<span class="macro">assert_eq!</span>(first, <span class="kw-2">&amp;mut </span><span class="string">"value1"</span>);
<span class="kw-2">*</span>first = <span class="string">"value3"</span>;

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="string">"value2"</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">None</span>);

<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value3"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#952-963">source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>&lt;KeyQuery&gt;(&amp;mut self, key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;KeyQuery</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut Value</a>&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;KeyQuery&gt;,
    KeyQuery: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Returns a mutable reference to the first value, by insertion order, associated with the given key, or <code>None</code> if
the key is not in the multimap.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-30"><a class="doc-anchor" href="#examples-30">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">None</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value"</span>));

<span class="kw">let </span><span class="kw-2">mut </span>value = map.get_mut(<span class="kw-2">&amp;</span><span class="string">"key"</span>).unwrap();
<span class="kw-2">*</span>value = <span class="string">"value2"</span>;

<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value2"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.insert" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#991-993">source</a><h4 class="code-header">pub fn <a href="#method.insert" class="fn">insert</a>(&amp;mut self, key: Key, value: Value) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Value&gt;</h4></section></summary><div class="docblock"><p>Inserts the key-value pair into the multimap and returns the first value, by insertion order, that was already
associated with the key.</p>
<p>If the key is not already in the multimap, <code>None</code> will be returned. If the key is already in the multimap, the
insertion ordering of the keys will remain unchanged.</p>
<p>Complexity: O(1) amortized</p>
<h5 id="examples-31"><a class="doc-anchor" href="#examples-31">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert!</span>(map.is_empty());

<span class="kw">let </span>old_value = map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert!</span>(old_value.is_none());
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value"</span>));

<span class="kw">let </span>old_value = map.insert(<span class="string">"key"</span>, <span class="string">"value2"</span>);
<span class="macro">assert_eq!</span>(old_value, <span class="prelude-val">Some</span>(<span class="string">"value"</span>));
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value2"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.insert_all" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1031-1058">source</a><h4 class="code-header">pub fn <a href="#method.insert_all" class="fn">insert_all</a>(
    &amp;mut self,
    key: Key,
    value: Value
) -&gt; <a class="struct" href="struct.EntryValuesDrain.html" title="struct ordered_multimap::list_ordered_multimap::EntryValuesDrain">EntryValuesDrain</a>&lt;'_, Key, Value&gt; <a href="#" class="tooltip" data-notable-ty="EntryValuesDrain&lt;&#39;_, Key, Value&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Inserts the key-value pair into the multimap and returns an iterator that yields all values previously associated
with the key by insertion order.</p>
<p>If the key is not already in the multimap, the iterator will yield no values.If the key is already in the
multimap, the insertion ordering of the keys will remain unchanged.</p>
<p>Complexity: O(1) amortized</p>
<h5 id="examples-32"><a class="doc-anchor" href="#examples-32">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();
<span class="macro">assert!</span>(map.is_empty());

{
  <span class="kw">let </span><span class="kw-2">mut </span>old_values = map.insert_all(<span class="string">"key"</span>, <span class="string">"value"</span>);
  <span class="macro">assert_eq!</span>(old_values.next(), <span class="prelude-val">None</span>);
}

<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value"</span>));

map.append(<span class="string">"key"</span>, <span class="string">"value2"</span>);

{
  <span class="kw">let </span><span class="kw-2">mut </span>old_values = map.insert_all(<span class="string">"key"</span>, <span class="string">"value3"</span>);
  <span class="macro">assert_eq!</span>(old_values.next(), <span class="prelude-val">Some</span>(<span class="string">"value"</span>));
  <span class="macro">assert_eq!</span>(old_values.next(), <span class="prelude-val">Some</span>(<span class="string">"value2"</span>));
  <span class="macro">assert_eq!</span>(old_values.next(), <span class="prelude-val">None</span>);
}

<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value3"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pack_to" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1090-1134">source</a><h4 class="code-header">pub fn <a href="#method.pack_to" class="fn">pack_to</a>(
    &amp;mut self,
    keys_minimum_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>,
    values_minimum_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>
)<div class="where">where
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a>,</div></h4></section></summary><div class="docblock"><p>Reorganizes the multimap to ensure maximum spatial locality and changes the key and value capacities to the
provided values.</p>
<p>This function can be used to actually increase the capacity of the multimap.</p>
<p>Complexity: O(|K| + |V|) where |K| is the number of keys and |V| is the number of values.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if either of the given minimum capacities are less than their current respective lengths.</p>
<h5 id="examples-33"><a class="doc-anchor" href="#examples-33">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::with_capacity(<span class="number">10</span>, <span class="number">10</span>);

map.insert(<span class="string">"key1"</span>, <span class="string">"value1"</span>);
map.insert(<span class="string">"key2"</span>, <span class="string">"value2"</span>);
map.append(<span class="string">"key2"</span>, <span class="string">"value3"</span>);
map.append(<span class="string">"key1"</span>, <span class="string">"value4"</span>);
map.pack_to(<span class="number">5</span>, <span class="number">5</span>);

<span class="macro">assert_eq!</span>(map.keys_capacity(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(map.keys_len(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(map.values_capacity(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">4</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pack_to_fit" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1159-1164">source</a><h4 class="code-header">pub fn <a href="#method.pack_to_fit" class="fn">pack_to_fit</a>(&amp;mut self)<div class="where">where
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a>,</div></h4></section></summary><div class="docblock"><p>Reorganizes the multimap to ensure maximum spatial locality and removes any excess key and value capacity.</p>
<p>Complexity: O(|K| + |V|) where |K| is the number of keys and |V| is the number of values.</p>
<h5 id="examples-34"><a class="doc-anchor" href="#examples-34">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::with_capacity(<span class="number">5</span>, <span class="number">5</span>);

map.insert(<span class="string">"key1"</span>, <span class="string">"value1"</span>);
map.insert(<span class="string">"key2"</span>, <span class="string">"value2"</span>);
map.append(<span class="string">"key2"</span>, <span class="string">"value3"</span>);
map.append(<span class="string">"key1"</span>, <span class="string">"value4"</span>);
map.pack_to_fit();

<span class="macro">assert_eq!</span>(map.keys_capacity(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(map.keys_len(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(map.values_capacity(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(map.values_len(), <span class="number">4</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_back" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1196-1233">source</a><h4 class="code-header">pub fn <a href="#method.pop_back" class="fn">pop_back</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="enum" href="enum.KeyWrapper.html" title="enum ordered_multimap::list_ordered_multimap::KeyWrapper">KeyWrapper</a>&lt;'_, Key&gt;, Value)&gt;</h4></section></summary><div class="docblock"><p>Removes the last key-value pair to have been inserted.</p>
<p>Because a single key can be associated with many values, the key returned by this function is a <a href="enum.KeyWrapper.html" title="enum ordered_multimap::list_ordered_multimap::KeyWrapper"><code>KeyWrapper</code></a>
which can be either owned or borrowed. If the value removed was the only value associated with the key, then the
key will be returned. Otherwise, a reference to the key will be returned.</p>
<p>This function along with <a href="struct.ListOrderedMultimap.html#method.pop_front" title="method ordered_multimap::list_ordered_multimap::ListOrderedMultimap::pop_front"><code>ListOrderedMultimap::pop_front</code></a> act as replacements for a drain iterator since an
iterator cannot be done over <a href="enum.KeyWrapper.html" title="enum ordered_multimap::list_ordered_multimap::KeyWrapper"><code>KeyWrapper</code></a>.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-35"><a class="doc-anchor" href="#examples-35">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;
<span class="kw">use </span>ordered_multimap::list_ordered_multimap::KeyWrapper;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();

map.insert(<span class="string">"key"</span>, <span class="string">"value1"</span>);
map.append(<span class="string">"key"</span>, <span class="string">"value2"</span>);

<span class="kw">let </span>(key, value) = map.pop_back().unwrap();
<span class="macro">assert_eq!</span>(key, KeyWrapper::Borrowed(<span class="kw-2">&amp;</span><span class="string">"key"</span>));
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>value, <span class="kw-2">&amp;</span><span class="string">"value2"</span>);

<span class="kw">let </span>(key, value) = map.pop_back().unwrap();
<span class="macro">assert_eq!</span>(key, KeyWrapper::Owned(<span class="string">"key"</span>));
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>value, <span class="kw-2">&amp;</span><span class="string">"value1"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_front" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1265-1302">source</a><h4 class="code-header">pub fn <a href="#method.pop_front" class="fn">pop_front</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="enum" href="enum.KeyWrapper.html" title="enum ordered_multimap::list_ordered_multimap::KeyWrapper">KeyWrapper</a>&lt;'_, Key&gt;, Value)&gt;</h4></section></summary><div class="docblock"><p>Removes the first key-value pair to have been inserted.</p>
<p>Because a single key can be associated with many values, the key returned by this function is a <a href="enum.KeyWrapper.html" title="enum ordered_multimap::list_ordered_multimap::KeyWrapper"><code>KeyWrapper</code></a>
which can be either owned or borrowed. If the value removed was the only value associated with the key, then the
key will be returned. Otherwise, a reference to the key will be returned.</p>
<p>This function along with <a href="struct.ListOrderedMultimap.html#method.pop_back" title="method ordered_multimap::list_ordered_multimap::ListOrderedMultimap::pop_back"><code>ListOrderedMultimap::pop_back</code></a> act as replacements for a drain iterator since an
iterator cannot be done over <a href="enum.KeyWrapper.html" title="enum ordered_multimap::list_ordered_multimap::KeyWrapper"><code>KeyWrapper</code></a>.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-36"><a class="doc-anchor" href="#examples-36">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;
<span class="kw">use </span>ordered_multimap::list_ordered_multimap::KeyWrapper;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();

map.insert(<span class="string">"key"</span>, <span class="string">"value1"</span>);
map.append(<span class="string">"key"</span>, <span class="string">"value2"</span>);

<span class="kw">let </span>(key, value) = map.pop_front().unwrap();
<span class="macro">assert_eq!</span>(key, KeyWrapper::Borrowed(<span class="kw-2">&amp;</span><span class="string">"key"</span>));
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>value, <span class="kw-2">&amp;</span><span class="string">"value1"</span>);

<span class="kw">let </span>(key, value) = map.pop_front().unwrap();
<span class="macro">assert_eq!</span>(key, KeyWrapper::Owned(<span class="string">"key"</span>));
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>value, <span class="kw-2">&amp;</span><span class="string">"value2"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1325-1331">source</a><h4 class="code-header">pub fn <a href="#method.remove" class="fn">remove</a>&lt;KeyQuery&gt;(&amp;mut self, key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;KeyQuery</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Value&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;KeyQuery&gt;,
    KeyQuery: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Removes all values associated with the given key from the map and returns the first value by insertion order.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-37"><a class="doc-anchor" href="#examples-37">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();

<span class="kw">let </span>removed_value = map.remove(<span class="kw-2">&amp;</span><span class="string">"key"</span>);
<span class="macro">assert_eq!</span>(removed_value, <span class="prelude-val">None</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value"</span>));

<span class="kw">let </span>removed_value = map.remove(<span class="kw-2">&amp;</span><span class="string">"key"</span>);
<span class="macro">assert_eq!</span>(removed_value, <span class="prelude-val">Some</span>(<span class="string">"value"</span>));
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove_all" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1364-1380">source</a><h4 class="code-header">pub fn <a href="#method.remove_all" class="fn">remove_all</a>&lt;KeyQuery&gt;(
    &amp;mut self,
    key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;KeyQuery</a>
) -&gt; <a class="struct" href="struct.EntryValuesDrain.html" title="struct ordered_multimap::list_ordered_multimap::EntryValuesDrain">EntryValuesDrain</a>&lt;'_, Key, Value&gt; <a href="#" class="tooltip" data-notable-ty="EntryValuesDrain&lt;&#39;_, Key, Value&gt;">ⓘ</a><div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;KeyQuery&gt;,
    KeyQuery: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Removes all values associated with the given key from the map and returns an iterator that yields those values.</p>
<p>If the key is not already in the map, the iterator will yield no values.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-38"><a class="doc-anchor" href="#examples-38">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();

{
    <span class="kw">let </span><span class="kw-2">mut </span>removed_values = map.remove_all(<span class="kw-2">&amp;</span><span class="string">"key"</span>);
    <span class="macro">assert_eq!</span>(removed_values.next(), <span class="prelude-val">None</span>);
}

map.insert(<span class="string">"key"</span>, <span class="string">"value1"</span>);
map.append(<span class="string">"key"</span>, <span class="string">"value2"</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value1"</span>));

{
    <span class="kw">let </span><span class="kw-2">mut </span>removed_values = map.remove_all(<span class="kw-2">&amp;</span><span class="string">"key"</span>);
    <span class="macro">assert_eq!</span>(removed_values.next(), <span class="prelude-val">Some</span>(<span class="string">"value1"</span>));
    <span class="macro">assert_eq!</span>(removed_values.next(), <span class="prelude-val">Some</span>(<span class="string">"value2"</span>));
    <span class="macro">assert_eq!</span>(removed_values.next(), <span class="prelude-val">None</span>);
}

<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove_entry" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1405-1412">source</a><h4 class="code-header">pub fn <a href="#method.remove_entry" class="fn">remove_entry</a>&lt;KeyQuery&gt;(&amp;mut self, key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;KeyQuery</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.tuple.html">(Key, Value)</a>&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;KeyQuery&gt;,
    KeyQuery: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Removes all values associated with the given key from the map and returns the key and first value.</p>
<p>If the key is not already in the map, then <code>None</code> will be returned.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-39"><a class="doc-anchor" href="#examples-39">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();

<span class="kw">let </span>entry = map.remove_entry(<span class="kw-2">&amp;</span><span class="string">"key"</span>);
<span class="macro">assert_eq!</span>(entry, <span class="prelude-val">None</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value"</span>));

<span class="kw">let </span>entry = map.remove_entry(<span class="kw-2">&amp;</span><span class="string">"key"</span>);
<span class="macro">assert_eq!</span>(entry, <span class="prelude-val">Some</span>((<span class="string">"key"</span>, <span class="string">"value"</span>)));
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove_entry_all" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1447-1467">source</a><h4 class="code-header">pub fn <a href="#method.remove_entry_all" class="fn">remove_entry_all</a>&lt;KeyQuery&gt;(
    &amp;mut self,
    key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;KeyQuery</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(Key, <a class="struct" href="struct.EntryValuesDrain.html" title="struct ordered_multimap::list_ordered_multimap::EntryValuesDrain">EntryValuesDrain</a>&lt;'_, Key, Value&gt;)&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;KeyQuery&gt;,
    KeyQuery: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Removes all values associated with the given key from the map and returns the key and an iterator that yields
those values.</p>
<p>If the key is not already in the map, then <code>None</code> will be returned.</p>
<p>Complexity: O(1)</p>
<h5 id="examples-40"><a class="doc-anchor" href="#examples-40">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();

{
    <span class="kw">let </span>entry = map.remove_entry_all(<span class="kw-2">&amp;</span><span class="string">"key"</span>);
    <span class="macro">assert!</span>(entry.is_none());
}

map.insert(<span class="string">"key"</span>, <span class="string">"value1"</span>);
map.append(<span class="string">"key"</span>, <span class="string">"value2"</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value1"</span>));

{
    <span class="kw">let </span>(key, <span class="kw-2">mut </span>iter) = map.remove_entry_all(<span class="kw-2">&amp;</span><span class="string">"key"</span>).unwrap();
    <span class="macro">assert_eq!</span>(key, <span class="string">"key"</span>);
    <span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="string">"value1"</span>));
    <span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="string">"value2"</span>));
    <span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">None</span>);
}

<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reserve_keys" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1490-1510">source</a><h4 class="code-header">pub fn <a href="#method.reserve_keys" class="fn">reserve_keys</a>(&amp;mut self, additional_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves additional capacity such that more keys can be stored in the multimap.</p>
<p>If the existing capacity minus the current length is enough to satisfy the additional capacity, the capacity will
remain unchanged.</p>
<p>If the capacity is increased, the capacity may be increased by more than what was requested.</p>
<h5 id="examples-41"><a class="doc-anchor" href="#examples-41">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::with_capacity(<span class="number">1</span>, <span class="number">1</span>);

map.insert(<span class="string">"key"</span>, <span class="string">"value"</span>);
<span class="macro">assert_eq!</span>(map.keys_capacity(), <span class="number">1</span>);

map.reserve_keys(<span class="number">10</span>);
<span class="macro">assert!</span>(map.keys_capacity() &gt;= <span class="number">11</span>);
<span class="macro">assert_eq!</span>(map.get(<span class="kw-2">&amp;</span><span class="string">"key"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"value"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.retain" class="method"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1535-1546">source</a><h4 class="code-header">pub fn <a href="#method.retain" class="fn">retain</a>&lt;Function&gt;(&amp;mut self, function: Function)<div class="where">where
    Function: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Key</a>, <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut Value</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Keeps all key-value pairs that satisfy the given predicate function.</p>
<p>Complexity: O(|V|) where |V| is the number of values</p>
<h5 id="examples-42"><a class="doc-anchor" href="#examples-42">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ordered_multimap::ListOrderedMultimap;

<span class="kw">let </span><span class="kw-2">mut </span>map = ListOrderedMultimap::new();

map.insert(<span class="string">"key1"</span>, <span class="number">1</span>);
map.insert(<span class="string">"key2"</span>, <span class="number">5</span>);
map.append(<span class="string">"key1"</span>, -<span class="number">1</span>);
map.insert(<span class="string">"key3"</span>, -<span class="number">10</span>);

map.retain(|<span class="kw">_</span>, <span class="kw-2">&amp;mut </span>value| value &gt;= <span class="number">0</span>);

<span class="kw">let </span><span class="kw-2">mut </span>iter = map.iter();
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key1"</span>, <span class="kw-2">&amp;</span><span class="number">1</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="string">"key2"</span>, <span class="kw-2">&amp;</span><span class="number">5</span>)));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#59">source</a><a href="#impl-Clone-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, Value: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#59">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.77.0/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1610-1618">source</a><a href="#impl-Debug-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,
    Value: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1615-1617">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, formatter: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.77.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.77.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-ListOrderedMultimap%3CKey,+Value%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1621-1625">source</a><a href="#impl-Default-for-ListOrderedMultimap%3CKey,+Value%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, <a class="type" href="type.RandomState.html" title="type ordered_multimap::list_ordered_multimap::RandomState">RandomState</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1622-1624">source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.77.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3C(%26Key,+%26Value)%3E-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1652-1664">source</a><a href="#impl-Extend%3C(%26Key,+%26Value)%3E-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;'a Key</a>, <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;'a Value</a>)&gt; for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    Value: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend" class="method trait-impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1658-1663">source</a><a href="#method.extend" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;Iter&gt;(&amp;mut self, iter: Iter)<div class="where">where
    Iter: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = (<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;'a Key</a>, <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;'a Value</a>)&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/iter/traits/collect.rs.html#376">source</a><a href="#method.extend_one" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/iter/traits/collect.rs.html#384">source</a><a href="#method.extend_reserve" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3C(Key,+Value)%3E-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1634-1650">source</a><a href="#impl-Extend%3C(Key,+Value)%3E-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.tuple.html">(Key, Value)</a>&gt; for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend-1" class="method trait-impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1639-1649">source</a><a href="#method.extend-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;Iter&gt;(&amp;mut self, iter: Iter)<div class="where">where
    Iter: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.tuple.html">(Key, Value)</a>&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/iter/traits/collect.rs.html#376">source</a><a href="#method.extend_one-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/iter/traits/collect.rs.html#384">source</a><a href="#method.extend_reserve-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C(Key,+Value)%3E-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1666-1679">source</a><a href="#impl-FromIterator%3C(Key,+Value)%3E-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.tuple.html">(Key, Value)</a>&gt; for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1671-1678">source</a><a href="#method.from_iter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;Iter&gt;(iter: Iter) -&gt; Self<div class="where">where
    Iter: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.tuple.html">(Key, Value)</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1696-1703">source</a><a href="#impl-IntoIterator-for-%26ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'map, Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'map <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><a href="#associatedtype.IntoIter" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.Iter.html" title="struct ordered_multimap::list_ordered_multimap::Iter">Iter</a>&lt;'map, Key, Value&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl"><a href="#associatedtype.Item" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = (<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;'map Key</a>, <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;'map Value</a>)</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1700-1702">source</a><a href="#method.into_iter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26mut+ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1705-1712">source</a><a href="#impl-IntoIterator-for-%26mut+ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'map, Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'map mut <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.IntoIter-1" class="associatedtype trait-impl"><a href="#associatedtype.IntoIter-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.IterMut.html" title="struct ordered_multimap::list_ordered_multimap::IterMut">IterMut</a>&lt;'map, Key, Value&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle" open><summary><section id="associatedtype.Item-1" class="associatedtype trait-impl"><a href="#associatedtype.Item-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = (<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;'map Key</a>, <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;'map mut Value</a>)</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter-1" class="method trait-impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1709-1711">source</a><a href="#method.into_iter-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1681-1694">source</a><a href="#impl-IntoIterator-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.IntoIter-2" class="associatedtype trait-impl"><a href="#associatedtype.IntoIter-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.IntoIter.html" title="struct ordered_multimap::list_ordered_multimap::IntoIter">IntoIter</a>&lt;Key, Value&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle" open><summary><section id="associatedtype.Item-2" class="associatedtype trait-impl"><a href="#associatedtype.Item-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.tuple.html">(Key, Value)</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter-2" class="method trait-impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1688-1693">source</a><a href="#method.into_iter-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.77.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1714-1726">source</a><a href="#impl-PartialEq-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,
    Value: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1719-1725">source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.77.0/src/core/cmp.rs.html#242">source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a class="src rightside" href="../../src/ordered_multimap/list_ordered_multimap.rs.html#1627-1632">source</a><a href="#impl-Eq-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a>,
    Value: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,</div></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a href="#impl-RefUnwindSafe-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,
    Value: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a href="#impl-Send-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,
    Value: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a href="#impl-Sync-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,
    Value: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a href="#impl-Unpin-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Value: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="impl"><a href="#impl-UnwindSafe-for-ListOrderedMultimap%3CKey,+Value,+State%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Key, Value, State&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.ListOrderedMultimap.html" title="struct ordered_multimap::list_ordered_multimap::ListOrderedMultimap">ListOrderedMultimap</a>&lt;Key, Value, State&gt;<div class="where">where
    Key: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,
    State: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,
    Value: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.77.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.77.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-Q" class="impl"><a class="src rightside" href="../../src/hashbrown/lib.rs.html#166-169">source</a><a href="#impl-Equivalent%3CK%3E-for-Q" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; <a class="trait" href="../../hashbrown/trait.Equivalent.html" title="trait hashbrown::Equivalent">Equivalent</a>&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent" class="method trait-impl"><a class="src rightside" href="../../src/hashbrown/lib.rs.html#171">source</a><a href="#method.equivalent" class="anchor">§</a><h4 class="code-header">fn <a href="../../hashbrown/trait.Equivalent.html#tymethod.equivalent" class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Checks if this value is equivalent to the given key. <a href="../../hashbrown/trait.Equivalent.html#tymethod.equivalent">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#764">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#767">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#757">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#804-806">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#811">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#789-791">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#796">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"EntryValues<'_, Key, Value>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.EntryValues.html\" title=\"struct ordered_multimap::list_ordered_multimap::EntryValues\">EntryValues</a>&lt;'map, Key, Value&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'map, Key, Value&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.EntryValues.html\" title=\"struct ordered_multimap::list_ordered_multimap::EntryValues\">EntryValues</a>&lt;'map, Key, Value&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map Value</a>;</div>","EntryValuesDrain<'_, Key, Value>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.EntryValuesDrain.html\" title=\"struct ordered_multimap::list_ordered_multimap::EntryValuesDrain\">EntryValuesDrain</a>&lt;'_, Key, Value&gt;</code></h3><pre><code><div class=\"where\">impl&lt;Key, Value&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.EntryValuesDrain.html\" title=\"struct ordered_multimap::list_ordered_multimap::EntryValuesDrain\">EntryValuesDrain</a>&lt;'_, Key, Value&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = Value;</div>","EntryValuesMut<'_, Key, Value>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.EntryValuesMut.html\" title=\"struct ordered_multimap::list_ordered_multimap::EntryValuesMut\">EntryValuesMut</a>&lt;'map, Key, Value&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'map, Key, Value&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.EntryValuesMut.html\" title=\"struct ordered_multimap::list_ordered_multimap::EntryValuesMut\">EntryValuesMut</a>&lt;'map, Key, Value&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map mut Value</a>;</div>","Iter<'_, Key, Value>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct ordered_multimap::list_ordered_multimap::Iter\">Iter</a>&lt;'map, Key, Value&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'map, Key, Value&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct ordered_multimap::list_ordered_multimap::Iter\">Iter</a>&lt;'map, Key, Value&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map Key</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map Value</a>);</div>","IterMut<'_, Key, Value>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct ordered_multimap::list_ordered_multimap::IterMut\">IterMut</a>&lt;'map, Key, Value&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'map, Key, Value&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct ordered_multimap::list_ordered_multimap::IterMut\">IterMut</a>&lt;'map, Key, Value&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map Key</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map mut Value</a>);</div>","KeyValues<'_, Key, Value, State>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.KeyValues.html\" title=\"struct ordered_multimap::list_ordered_multimap::KeyValues\">KeyValues</a>&lt;'map, Key, Value, State&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'map, Key, Value, State&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.KeyValues.html\" title=\"struct ordered_multimap::list_ordered_multimap::KeyValues\">KeyValues</a>&lt;'map, Key, Value, State&gt;<div class=\"where\">where\n    Key: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a>,\n    State: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/hash/trait.BuildHasher.html\" title=\"trait core::hash::BuildHasher\">BuildHasher</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map Key</a>, <a class=\"struct\" href=\"struct.EntryValues.html\" title=\"struct ordered_multimap::list_ordered_multimap::EntryValues\">EntryValues</a>&lt;'map, Key, Value&gt;);</div>","KeyValuesMut<'_, Key, Value, State>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.KeyValuesMut.html\" title=\"struct ordered_multimap::list_ordered_multimap::KeyValuesMut\">KeyValuesMut</a>&lt;'map, Key, Value, State&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'map, Key, Value, State&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.KeyValuesMut.html\" title=\"struct ordered_multimap::list_ordered_multimap::KeyValuesMut\">KeyValuesMut</a>&lt;'map, Key, Value, State&gt;<div class=\"where\">where\n    Key: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a>,\n    State: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/hash/trait.BuildHasher.html\" title=\"trait core::hash::BuildHasher\">BuildHasher</a>,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map Key</a>, <a class=\"struct\" href=\"struct.EntryValuesMut.html\" title=\"struct ordered_multimap::list_ordered_multimap::EntryValuesMut\">EntryValuesMut</a>&lt;'map, Key, Value&gt;);</div>","Keys<'_, Key>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Keys.html\" title=\"struct ordered_multimap::list_ordered_multimap::Keys\">Keys</a>&lt;'map, Key&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'map, Key&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Keys.html\" title=\"struct ordered_multimap::list_ordered_multimap::Keys\">Keys</a>&lt;'map, Key&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map Key</a>;</div>","Values<'_, Key, Value>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Values.html\" title=\"struct ordered_multimap::list_ordered_multimap::Values\">Values</a>&lt;'map, Key, Value&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'map, Key, Value&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Values.html\" title=\"struct ordered_multimap::list_ordered_multimap::Values\">Values</a>&lt;'map, Key, Value&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map Value</a>;</div>","ValuesMut<'_, Key, Value>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.ValuesMut.html\" title=\"struct ordered_multimap::list_ordered_multimap::ValuesMut\">ValuesMut</a>&lt;'map, Key, Value&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'map, Key, Value&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.ValuesMut.html\" title=\"struct ordered_multimap::list_ordered_multimap::ValuesMut\">ValuesMut</a>&lt;'map, Key, Value&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.reference.html\">&amp;'map mut Value</a>;</div>"}</script></section></div></main></body></html>