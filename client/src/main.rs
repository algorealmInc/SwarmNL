//! Copyright 2024 Algorealm, Inc.

//! This example models a distributed network and is a rough sketch to help in determining concrete
//! features to be built

use std::{
	collections::{HashMap, VecDeque},
	sync::Arc,
	time::Duration,
};

use rand::random;
use swarm_nl::{
	core::{
		gossipsub_cfg::GossipsubConfig, AppData, AppResponse, Core, CoreBuilder, NetworkEvent,
		RpcConfig,
	},
	setup::BootstrapConfig,
	Keypair, MessageId, MultiaddrString, PeerId, PeerIdString, Port,
};
use tokio::sync::Mutex;
use util::sleep_for;

/// The id of the gossip mesh network
pub const GOSSIP_NETWORK: &str = "random";

/// Amount of time to wait for proper sync
pub const WAIT_TIME: u64 = 3;

/// Basic node information
pub struct NodeInfo {
	/// Node identifier,
	name: String,
	/// Broadcast state, used to make sure we've recieved from both our peers
	state: HashMap<PeerId, u8>,
	/// Nonce
	nonce: Vec<u32>,
}

/// Handle incoming RPC
fn rpc_incoming_message_handler(data: Vec<Vec<u8>>) -> Vec<Vec<u8>> {
	// Geenerate and return random number to peer
	let random_number = util::generate_random_number();

	vec![vec![random_number]]
}

/// Handle gissiping
fn gossipsub_filter_fn(
	propagation_source: PeerId,
	message_id: MessageId,
	source: Option<PeerId>,
	topic: String,
	data: Vec<String>,
) -> bool {
	true
}

/// Create a detereministic node
async fn setup_node(
	ports: (Port, Port),
	deterministic_protobuf: &[u8],
	boot_nodes: HashMap<PeerIdString, MultiaddrString>,
) -> Core {
	// Configure the node deterministically so we can connect to it
	let mut protobuf = &mut deterministic_protobuf.to_owned()[..];

	let config = BootstrapConfig::default()
		.generate_keypair_from_protobuf("ed25519", &mut protobuf)
		.with_tcp(ports.0)
		.with_udp(ports.1)
		// configure bootnodes, so we can connect to our sister nodes
		.with_bootnodes(boot_nodes);

	// Set up network
	let mut builder = CoreBuilder::with_config(config);

	// Configure RPC handling
	builder = builder.with_rpc(RpcConfig::Default, rpc_incoming_message_handler);

	// Configure gossipsub
	// Specify the gossip filter algorithm
	let filter_fn = gossipsub_filter_fn;
	let builder = builder.with_gossipsub(GossipsubConfig::Default, filter_fn);

	// Finish build
	builder.build().await.unwrap()
}

/// Consume buffer and perform operations on the data retrieved
async fn consume_buffer(
	mut node: Core,
	name: String,
	storage_addr: String,
	buffer: Arc<Mutex<VecDeque<String>>>,
) {
	loop {
		while let Some(data) = buffer.lock().await.pop_front()
		/* just here is the critical section */
		{
			// First we save it to local storage
			match util::write_to_file(&storage_addr, &data) {
				Ok(_) => {
					println!("[{name}]>>> Incoming data successfully saved to storage");

					// Now we gossip data recieved to peers
					// Prepare message
					let gossip_request = AppData::GossipsubBroadcastMessage {
						topic: GOSSIP_NETWORK.to_string(),
						message: vec![data.clone().into()],
					};

					// Send request
					if let Ok(_) = node.query_network(gossip_request).await {
						println!("[{name}]>>> Data sent to peers: {}", data);
					} else {
						println!("[{name}]>>> Could not gossip to peers");
					}
				},
				Err(e) => println!("[{name}]>>> Error saving data: {e}"),
			}
		}

		// Sleep a while
		sleep_for(4).await;
	}
}

/// Handle incoming gossip and syncronize with the network
async fn handle_incoming_gossip(name: String, mut node: Core, storage_addr: String) {
	loop {
		// We'll keep polling for gossip events as they come in
		while let Some(event) = node.next_event().await {
			match event {
				// Handle incoming broadcast of random numbers generated by our peers
				NetworkEvent::GossipsubIncomingMessageHandled { source: _, data } => {
					// Extract data
					let incoming_data = data[0].clone();

					println!(
						"[{name}]>>> Incoming data recieved from peer: {}",
						incoming_data
					);

					// Insert it to local storage and arrange it properly
					if let Ok(lines) = util::read_lines(&storage_addr) {
						// First, lets get the number of idiom
						let index_string = incoming_data.split('.').collect::<Vec<_>>()[0];
						let index = index_string.parse::<u8>().unwrap();

						let (mut before_index, mut after_index): (Vec<String>, Vec<String>) = lines
							.filter_map(Result::ok)
							.partition(|line| line.contains(&format!("{}", index - 1)));

						// Now join it to the former slice
						before_index.push(incoming_data);

						// Concatenate the slices
						before_index.append(&mut after_index);

						// save to file
						match util::write_lines_sync(&storage_addr, &before_index[..]) {
							Ok(_) => println!("[{name}]>>> Data sucessfully sychronized locally"),
							Err(_) => println!("[{name}]>>> Local synchronization failed"),
						};
					}
				},
				_ => {},
			}
		}

		// Wait a little for messages to come in
		util::sleep_for(WAIT_TIME).await;
	}
}

// #[cfg(feature = "first-node")]
async fn run_node(
	name: &str,
	ports_1: (Port, Port),
	ports_2: (Port, Port),
	ports_3: (Port, Port),
	peer_ids: (PeerId, PeerId),
	keypair: [u8; 68],
	http_port: Port,
	storage_addr: String,
) {
	// Bootnodes
	let mut bootnodes = HashMap::new();
	bootnodes.insert(
		peer_ids.0.to_base58(),
		format!("/ip4/127.0.0.1/tcp/{}", ports_2.0),
	);

	bootnodes.insert(
		peer_ids.1.to_base58(),
		format!("/ip4/127.0.0.1/tcp/{}", ports_3.0),
	);

	// Setup node 1 and try to connect to node 2 and 3
	let mut node = setup_node(ports_1, &keypair[..], bootnodes).await;

	// Temporaqry data buffer
	let buffer: VecDeque<String> = VecDeque::new();
	let temp_buffer = Arc::new(Mutex::new(buffer));

	// Spawn an HTTP server that writes the incoming data to the internal buffer
	let node_name = name.to_owned();
	let buffer = temp_buffer.clone();
	tokio::task::spawn(async move {
		util::setup_server(buffer, node_name, http_port).await;
	});

	// Spin up a task to consume buffer as data comes in
	let node_name = name.to_owned();
	let node_copy = node.clone();
	let storage_address = storage_addr.clone();
	tokio::task::spawn(consume_buffer(
		node_copy,
		node_name,
		storage_address,
		temp_buffer,
	));

	// Wait a little for setup and connections
	tokio::time::sleep(Duration::from_secs(WAIT_TIME)).await;

	println!("{:?}", node.next_event().await);

	// Read events generated at setup
	while let Some(event) = node.next_event().await {
		match event {
			NetworkEvent::NewListenAddr {
				local_peer_id,
				listener_id: _,
				address,
			} => {
				// Announce interfaces we're listening on
				println!("Peer id: {}", local_peer_id);
				println!("We're listening on {}", address);
			},
			NetworkEvent::ConnectionEstablished {
				peer_id,
				connection_id: _,
				endpoint: _,
				num_established: _,
				established_in: _,
			} => {
				println!("Connection established with peer: {:?}", peer_id);
			},
			_ => {},
		}
	}

	// Join a common network (subscribe to a topic)
	let join_request = AppData::GossipsubJoinNetwork(GOSSIP_NETWORK.to_string());

	// Send request to network
	let stream_id = node.send_to_network(join_request).await.unwrap();
	if let Ok(_) = node.recv_from_network(stream_id).await {
		println!("[{name}]>>> Setup and ready to roll!");

		// Spin up task to monitor the network events
		let node_copy = node.clone();
		let addr = storage_addr.clone();
		let node_name = name.to_owned();
		tokio::task::spawn(handle_incoming_gossip(node_name, node_copy, addr));

		// Keep alive
		loop {}
	} else {
		panic!("[{name}]>>> Could not join mesh network");
	}
}

#[tokio::main]
async fn main() {
	// Node 1 keypair
	let node_1_keypair: [u8; 68] = [
		8, 1, 18, 64, 34, 116, 25, 74, 122, 174, 130, 2, 98, 221, 17, 247, 176, 102, 205, 3, 27,
		202, 193, 27, 6, 104, 216, 158, 235, 38, 141, 58, 64, 81, 157, 155, 36, 193, 50, 147, 85,
		72, 64, 174, 65, 132, 232, 78, 231, 224, 88, 38, 55, 78, 178, 65, 42, 97, 39, 152, 42, 164,
		148, 159, 36, 170, 109, 178,
	];

	// Node 2 Keypair
	let node_2_keypair: [u8; 68] = [
		8, 1, 18, 64, 37, 37, 86, 103, 79, 48, 103, 83, 170, 172, 131, 160, 15, 138, 237, 128, 114,
		144, 239, 7, 37, 6, 217, 25, 202, 210, 55, 89, 55, 93, 0, 153, 82, 226, 1, 54, 240, 36,
		110, 110, 173, 119, 143, 79, 44, 82, 126, 121, 247, 154, 252, 215, 43, 21, 101, 109, 235,
		10, 127, 128, 52, 52, 68, 31,
	];

	// Node 3 Keypair
	let node_3_keypair: [u8; 68] = [
		8, 1, 18, 64, 211, 172, 68, 234, 95, 121, 188, 130, 107, 113, 212, 215, 211, 189, 219, 190,
		137, 91, 250, 222, 34, 152, 190, 117, 139, 199, 250, 5, 33, 65, 14, 180, 214, 5, 151, 109,
		184, 106, 73, 186, 126, 52, 59, 220, 170, 158, 195, 249, 110, 74, 222, 161, 88, 194, 187,
		112, 95, 131, 113, 251, 106, 94, 61, 177,
	];

	// Get Peer Id's
	let peer_id_1 = Keypair::from_protobuf_encoding(&node_1_keypair)
		.unwrap()
		.public()
		.to_peer_id();

	let peer_id_2 = Keypair::from_protobuf_encoding(&node_2_keypair)
		.unwrap()
		.public()
		.to_peer_id();

	let peer_id_3 = Keypair::from_protobuf_encoding(&node_3_keypair)
		.unwrap()
		.public()
		.to_peer_id();

	// Ports
	let ports_1: (Port, Port) = (49152, 55003);
	let ports_2: (Port, Port) = (49153, 55001);
	let ports_3: (Port, Port) = (49154, 55002);

	// HTTP Ports
	let http_ports = [4000, 4001, 4002];

	// Storage addresses
	let storage_addrs = ["node-1/file.txt", "node-2/file.txt", "node-3/file.txt"];

	// Spin up first server
	#[cfg(feature = "first-node")]
	{
		run_node(
			"Node 1",
			ports_1,
			ports_2,
			ports_3,
			(peer_id_2, peer_id_3),
			node_1_keypair,
			http_ports[0],
			storage_addrs[0].to_string(),
		)
		.await;
	}

	// Spin up second server
	#[cfg(feature = "second-node")]
	{
		run_node(
			"Node 2",
			ports_2,
			ports_1,
			ports_3,
			(peer_id_1, peer_id_3),
			node_2_keypair,
			http_ports[1],
			storage_addrs[1].to_string(),
		)
		.await;
	}

	// Spin up third server
	#[cfg(feature = "third-node")]
	{
		run_node(
			"Node 3",
			ports_3,
			ports_1,
			ports_2,
			(peer_id_1, peer_id_2),
			node_3_keypair,
			http_ports[2],
			storage_addrs[2].to_string(),
		)
		.await;
	}

	// Spin up client
	#[cfg(feature = "client")]
	{
		// Initialize client
		let file_name = "client/file.txt";
		// Run
		util::run_client(file_name, http_ports).await;
	}
}

/// Module containing utility functions
mod util {
	use std::{
		collections::VecDeque,
		fs::{File, OpenOptions},
		io::{self, BufRead},
		io::{Result as IoResult, Write},
		path::Path,
	};

	use super::*;
	use rand::Rng;
	use reqwest::Client;
	use warp::{
		hyper::{body::Bytes, StatusCode},
		Filter,
	};

	/// Generate random number
	pub fn generate_random_number() -> u8 {
		let mut rng = rand::thread_rng(); // Initialize the random number generator
		rng.gen_range(1..=100) // Generate a number between 1 and 100 inclusive
	}

	/// Sleep for a specified duration
	pub async fn sleep_for(duration: u64) {
		tokio::time::sleep(Duration::from_secs(duration)).await;
	}

	/// Setup a HTTP server to recieve data from outside the network
	pub async fn setup_server(
		temp_buffer: Arc<Mutex<VecDeque<String>>>,
		node_name: String,
		http_port: Port,
	) {
		// Allow CORS
		let cors = warp::cors()
			.allow_origin("http://127.0.0.1")
			.allow_methods(vec!["GET", "POST", "DELETE"]);

		// Define a POST route that accepts binary data
		let upload_route = warp::post()
			.and(warp::path("upload"))
			.and(warp::body::bytes()) // Accept raw bytes as the body
			.and_then(move |bytes: Bytes| {
				let node_name = node_name.clone();
				let temp_buffer = temp_buffer.clone();

				async move {
					// Convert bytes to string
					let data = String::from_utf8(bytes.to_vec()).unwrap();

					// Print the received string data
					println!("[{}]>>> Received data of length: {}", node_name, data.len());

					// Save to internal buffer
					temp_buffer.lock().await.push_back(data);

					// Return a success response
					Ok::<_, warp::Rejection>(warp::reply::with_status(
						"String data received",
						StatusCode::OK,
					))
				}
			})
			.with(cors);

		println!("Setting up HTTP server, listening on port {http_port}");

		// Start the server on specified port
		warp::serve(upload_route)
			.run(([127, 0, 0, 1], http_port))
			.await;
	}

	/// Write text to a file
	pub fn write_to_file(filename: &str, text: &str) -> IoResult<()> {
		// Open the file in append mode, create if it doesn't exist
		let mut file = OpenOptions::new()
			.write(true)
			.append(true)
			.create(true)
			.open(filename)?;

		// Write the text into the file
		writeln!(file, "{}", text)?;

		Ok(())
	}

	/// Setup a client that would send requests to the network
	pub async fn run_client(file_path: &str, ports: [Port; 3]) {
		let file_path = file_path.to_owned();

		// Spin up a task that consistently writes data to the network
		let handle = tokio::task::spawn(async move {
			// Initialize the reqwest client
			let client = Client::new();
			let mut i = 0;

			loop {
				if let Ok(lines) = read_lines(&file_path) {
					// Read the file line by line
					for line in lines {
						if let Ok(content) = line {
							// Send the line content to the server
							match send_to_server(&client, &content, ports[i]).await {
								Ok(response) => println!("Server responded: {}", response),
								Err(e) => eprintln!("Error sending data: {:?}", e),
							}

							// Simulate some delay to avoid overwhelming the server
							sleep_for(2).await;
						}

						// Modify the counter to balance load on the servers
						i = (i + 1) % 3;
					}
				}
				// After finishing the file, start over again
				println!("Finished reading the file. Starting over...");
			}
		});

		// Await the task to ensure it runs to completion
		if let Err(e) = handle.await {
			eprintln!("Task failed with error: {:?}", e);
		}
	}

	// Send data to the server
	async fn send_to_server(
		client: &Client,
		data: &str,
		port: Port,
	) -> Result<String, reqwest::Error> {
		// Format the URL using the provided port
		let url = format!("http://127.0.0.1:{}/upload", port);

		// Send the POST request
		let res = client
			.post(&url) // Use the formatted URL
			.body(data.to_string())
			.send()
			.await?;

		println!("Response status: {:?}", res.status());

		// Return the server response as text
		Ok(res.text().await?)
	}

	// Read lines from a file
	pub fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
	where
		P: AsRef<Path>,
	{
		let file = File::open(filename)?;
		Ok(io::BufReader::new(file).lines())
	}

	/// Synchronous function to write lines to a file, overwriting its content
	pub fn write_lines_sync(filename: &str, lines: &[String]) -> IoResult<()> {
		// Open the file in write mode, truncating the file to overwrite it
		let mut file = OpenOptions::new()
			.write(true)
			.truncate(true) // Overwrite file contents
			.create(true)
			.open(filename)?;

		// Write each line to the file
		for line in lines {
			writeln!(file, "{}", line)?; // Writes the line with a newline
		}

		Ok(())
	}
}
